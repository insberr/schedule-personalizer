{"mappings":"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","sources":["src/src/types.ts","src/src/lib.ts","src/src/statements.ts","src/src/execute.ts","src/src/grammer.ts","src/src/checkers.ts","src/src/scsfs.ts","src/src/scs.ts","src/scs.ts"],"sourcesContent":[null,null,null,null,null,null,null,null,"//import { inspect } from \"util\";\nimport { Context, executeBlock } from './execute';\nimport { parse as pe } from './grammer';\nimport {\n    Arg,\n    Block,\n    LintLevel,\n    LintObject,\n    MinifyOptions,\n    Statement,\n} from './types';\nexport * from './types';\nimport { isStatement, parseTimeRange, recurseInto } from './lib';\nimport { isSameDay } from 'date-fns';\nimport { checkers } from './checkers';\nimport { StatementMap } from './statements';\nimport produce from 'immer';\n\nexport { _statements } from './statements';\nexport { checkers as _checkers } from './checkers';\n\nfunction quoteEscape(str: string): string {\n    let newStr = str;\n    newStr = newStr.replace(/\"/g, '\\\\\"');\n    newStr = newStr.replace(/'/g, \"\\\\'\");\n    return newStr;\n}\n\nfunction stringArgToString(str: string): string {\n    return `'${quoteEscape(str)}'`;\n}\n\nexport class SCS {\n    parsed: Block;\n    resolver: (name: string) => string;\n    //parsedwithComments: Block\n    constructor(data: string, resolver?: (name: string) => string) {\n        this.parsed = pe(data);\n        this.resolver =\n            resolver ||\n            ((name) => {\n                throw new Error(\n                    'Cannot resolve without a resolver. - Name: ' + name\n                );\n            });\n        //this.parsedwithComments = this.parsed;\n    }\n    scheduleFor(\n        date: Date,\n        context?: Context\n    ): { schedule: unknown; event: unknown } | undefined {\n        // @todo pls add type\n        // this function should do way more processing, ie including lunch info\n        // also adding default schedules\n        const execed = this.exec({ displayDate: date, ...context });\n        for (const _element of execed.events) {\n            const element: { dates: Date[]; schedule: string } = _element;\n            if (!element.dates) {\n                continue;\n            }\n            if (element.dates.find((e) => isSameDay(e, date))) {\n                return {\n                    schedule: execed.schedules[element.schedule],\n                    event: element,\n                };\n            }\n        }\n    }\n    minify(options?: MinifyOptions): string {\n        // TODO: finish options\n\n        let out = '';\n        function minifyStatement(statement: Statement | Block): string {\n            let out = '';\n            if (isStatement(statement)) {\n                // statement\n                let args =\n                    ' ' +\n                    statement.args\n                        .map((arg) => {\n                            if (arg.type == 'block') {\n                                return minifyStatement(arg.data).trim();\n                            } else if (arg.type == 'quote') {\n                                return stringArgToString(arg.data);\n                            } else if (arg.type == 'text') {\n                                return arg.data;\n                            } else if (arg.type == 'bracket') {\n                                return '[' + arg.data + ']';\n                            }\n                        })\n                        .join(' ');\n                if (statement.args.length == 0) {\n                    args = '';\n                }\n                if (statement.statement === 'comment') {\n                    if (options?.keepSingleLineComments) {\n                        // The extra space at the start and end is important\n                        out += ` /* [single] ${statement.comment} */ `;\n                    }\n                    return out;\n                } else if (statement.statement === 'multicomment') {\n                    // TODO add uncompress multi line comments\n                    if (options?.keepMultiLineComments) {\n                        out += ` /* ${(statement.comment as string).replace(\n                            /\\n/gm,\n                            ''\n                        )} */ `;\n                    }\n                    return out;\n                }\n                out += statement.statement + args;\n                out += ';';\n            } else {\n                // block\n                return '{' + statement.map(minifyStatement).join('') + '}';\n            }\n            return out;\n        }\n        for (const statement of this.parsed) {\n            out += minifyStatement(statement);\n        }\n        return out;\n    }\n    lint(): LintObject[] {\n        const objs: LintObject[] = [];\n        recurseInto(this.parsed, (statement, parent) => {\n            if (\n                statement.statement === 'comment' ||\n                statement.statement === 'multicomment'\n            ) {\n                return;\n            }\n            const e = checkers.get(statement.statement);\n            if (!e) {\n                if (StatementMap.get(statement.statement)) {\n                    objs.push({\n                        level: LintLevel.info,\n                        message: `No checker for statement: ${statement.statement}`,\n                        location: statement.location,\n                    });\n                } else {\n                    objs.push({\n                        level: LintLevel.error,\n                        message: `Unknown statement: ${statement.statement}`,\n                        location: statement.location,\n                    });\n                }\n            } else {\n                const ret = e(statement, parent);\n                if (ret) {\n                    objs.push({ ...ret, location: statement.location });\n                }\n            }\n        });\n        return objs;\n    }\n    pretty(): string {\n        let deep = 0;\n        let out = '';\n        function doPretty(statement: Statement | Block): string {\n            let o = '';\n            const indent = ' '.repeat(deep * 4);\n            if (isStatement(statement)) {\n                // statement\n                let args = '';\n\n                if (statement.args.length > 0) {\n                    args =\n                        ' ' +\n                        statement.args\n                            .map((arg) => {\n                                if (arg.type == 'block') {\n                                    return doPretty(arg.data).trim();\n                                } else if (arg.type == 'quote') {\n                                    return stringArgToString(arg.data);\n                                } else if (arg.type == 'text') {\n                                    return arg.data;\n                                } else if (arg.type == 'bracket') {\n                                    return '[' + arg.data + ']';\n                                }\n                            })\n                            .join(' ');\n                }\n\n                if (statement.statement == 'comment') {\n                    o += indent + '//' + (statement.comment as string) + '\\n';\n                } else if (statement.statement == 'multicomment') {\n                    o +=\n                        indent +\n                        '/*\\n' +\n                        (statement.comment as string)\n                            .trimStart()\n                            .replace(/^/, '\\n' + indent)\n                            .replace('\\n', indent) +\n                        '*/\\n';\n                } else {\n                    o += indent + statement.statement + args;\n                    let endNewLine = '\\n';\n                    if (o.endsWith('}')) {\n                        o += ';';\n                        endNewLine = '\\n\\n';\n                    } else {\n                        o += ';';\n                        endNewLine = '\\n';\n                    }\n\n                    if (statement.comment) {\n                        o +=\n                            ' //' +\n                            (\n                                statement.comment as {\n                                    statement: string;\n                                    args: Arg[];\n                                    comment: string;\n                                }\n                            ).comment;\n                    }\n\n                    o += endNewLine;\n                }\n            } else {\n                // block\n                o += indent + '{\\n';\n                deep++;\n                for (const statemen of statement) {\n                    o += doPretty(statemen);\n                }\n                deep--;\n                o += indent + '}\\n';\n            }\n            return o;\n        }\n        for (const statement of this.parsed) {\n            let newLine = '\\n';\n            if ((statement as Statement).statement !== undefined) {\n                if (\n                    (statement as Statement).statement === 'comment' ||\n                    (statement as Statement).statement === 'multicomment'\n                ) {\n                    newLine = '';\n                }\n            }\n            out += newLine + doPretty(statement);\n        }\n\n        out = out.trimStart();\n\n        // figure out how to just not make the extra new lines lol\n        const extraNewlines = out.match(/\\n{3}/gm);\n        if (extraNewlines) {\n            for (const newline of extraNewlines) {\n                // get position of newlines\n                const pos = out.indexOf(newline);\n                // replace the newlines with one newline\n                out =\n                    out.slice(0, pos) +\n                    '\\n\\n' +\n                    out.slice(pos + newline.length);\n            }\n        }\n\n        return out;\n    }\n    exec(initalContext?: Context): Context {\n        const ret = executeBlock(\n            this.parsed,\n            initalContext || {},\n            this.resolver\n        );\n        // transform the context into the right data format here\n        // fuck you\n        const newret: any = {};\n        for (const key in ret) {\n            if (key.startsWith('func_')) {\n                continue;\n            }\n            newret[key] = ret[key];\n        }\n        return newret;\n    }\n    bundle(): string {\n        const e = produce(this.parsed, (p: any) => {\n            const dofunny = (b: Block | Statement, parent?: Statement) => {\n                if (Array.isArray(b)) {\n                    b.forEach((e, i) => {\n                        if ((e as Statement).statement == 'import') {\n                            const impst = e as Statement;\n                            const toimp = impst.args[0].data as string;\n                            const imp = this.resolver(toimp);\n                            const parsed = new SCS(imp, this.resolver);\n                            const bundledDep = parsed.bundle();\n                            const newBlock = pe(bundledDep) as Block;\n                            newBlock.unshift({\n                                statement: 'comment',\n                                args: [],\n                                comment: ' *' + toimp + '*',\n                                location: {\n                                    start: { offset: 0, line: 0, column: 0 },\n                                    end: { offset: 0, line: 0, column: 0 },\n                                },\n                            } as Statement);\n                            b[i] = newBlock;\n                            return;\n                        }\n                        dofunny(e, parent);\n                    });\n                } else {\n                    b.args.forEach((c) => {\n                        if (c.type == 'block') {\n                            dofunny(c.data, b);\n                        }\n                    });\n                }\n            };\n            dofunny(p);\n        });\n        const n = new SCS('e;');\n        n.parsed = e;\n        return n.pretty();\n    }\n}\n\nexport { SCSFS } from './scsfs';\n"],"names":[],"version":3,"file":"scs.d.ts.map"}