{"mappings":"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","sources":["src/scs.ts","src/execute.ts","src/lib.ts","src/statements.ts","src/grammer.ts","src/types.ts","src/checkers.ts","src/scsfs.ts"],"sourcesContent":["//import { inspect } from \"util\";\nimport { Context, executeBlock } from './execute';\nimport { parse as pe } from './grammer';\nimport {\n    Arg,\n    Block,\n    LintLevel,\n    LintObject,\n    MinifyOptions,\n    Statement,\n} from './types';\nexport * from './types';\nimport { isStatement, parseTimeRange, recurseInto } from './lib';\nimport { isSameDay } from 'date-fns';\nimport { checkers } from './checkers';\nimport { StatementMap } from './statements';\nimport produce from 'immer';\n\nexport { _statements } from './statements';\nexport { checkers as _checkers } from './checkers';\n\nfunction quoteEscape(str: string): string {\n    let newStr = str;\n    newStr = newStr.replace(/\"/g, '\\\\\"');\n    newStr = newStr.replace(/'/g, \"\\\\'\");\n    return newStr;\n}\n\nfunction stringArgToString(str: string): string {\n    return `'${quoteEscape(str)}'`;\n}\n\nexport class SCS {\n    parsed: Block;\n    resolver: (name: string) => string;\n    //parsedwithComments: Block\n    constructor(data: string, resolver?: (name: string) => string) {\n        this.parsed = pe(data);\n        this.resolver =\n            resolver ||\n            ((name) => {\n                throw new Error(\n                    'Cannot resolve without a resolver. - Name: ' + name\n                );\n            });\n        //this.parsedwithComments = this.parsed;\n    }\n    scheduleFor(\n        date: Date,\n        context?: Context\n    ): { schedule: unknown; event: unknown } | undefined {\n        // @todo pls add type\n        // this function should do way more processing, ie including lunch info\n        // also adding default schedules\n        const execed = this.exec({ displayDate: date, ...context });\n        for (const _element of execed.events) {\n            const element: { dates: Date[]; schedule: string } = _element;\n            if (!element.dates) {\n                continue;\n            }\n            if (element.dates.find((e) => isSameDay(e, date))) {\n                return {\n                    schedule: execed.schedules[element.schedule],\n                    event: element,\n                };\n            }\n        }\n    }\n    minify(options?: MinifyOptions): string {\n        // TODO: finish options\n\n        let out = '';\n        function minifyStatement(statement: Statement | Block): string {\n            let out = '';\n            if (isStatement(statement)) {\n                // statement\n                let args =\n                    ' ' +\n                    statement.args\n                        .map((arg) => {\n                            if (arg.type == 'block') {\n                                return minifyStatement(arg.data).trim();\n                            } else if (arg.type == 'quote') {\n                                return stringArgToString(arg.data);\n                            } else if (arg.type == 'text') {\n                                return arg.data;\n                            } else if (arg.type == 'bracket') {\n                                return '[' + arg.data + ']';\n                            }\n                        })\n                        .join(' ');\n                if (statement.args.length == 0) {\n                    args = '';\n                }\n                if (statement.statement === 'comment') {\n                    if (options?.keepSingleLineComments) {\n                        // The extra space at the start and end is important\n                        out += ` /* [single] ${statement.comment} */ `;\n                    }\n                    return out;\n                } else if (statement.statement === 'multicomment') {\n                    // TODO add uncompress multi line comments\n                    if (options?.keepMultiLineComments) {\n                        out += ` /* ${(statement.comment as string).replace(\n                            /\\n/gm,\n                            ''\n                        )} */ `;\n                    }\n                    return out;\n                }\n                out += statement.statement + args;\n                out += ';';\n            } else {\n                // block\n                return '{' + statement.map(minifyStatement).join('') + '}';\n            }\n            return out;\n        }\n        for (const statement of this.parsed) {\n            out += minifyStatement(statement);\n        }\n        return out;\n    }\n    lint(): LintObject[] {\n        const objs: LintObject[] = [];\n        recurseInto(this.parsed, (statement, parent) => {\n            if (\n                statement.statement === 'comment' ||\n                statement.statement === 'multicomment'\n            ) {\n                return;\n            }\n            const e = checkers.get(statement.statement);\n            if (!e) {\n                if (StatementMap.get(statement.statement)) {\n                    objs.push({\n                        level: LintLevel.info,\n                        message: `No checker for statement: ${statement.statement}`,\n                        location: statement.location,\n                    });\n                } else {\n                    objs.push({\n                        level: LintLevel.error,\n                        message: `Unknown statement: ${statement.statement}`,\n                        location: statement.location,\n                    });\n                }\n            } else {\n                const ret = e(statement, parent);\n                if (ret) {\n                    objs.push({ ...ret, location: statement.location });\n                }\n            }\n        });\n        return objs;\n    }\n    pretty(): string {\n        let deep = 0;\n        let out = '';\n        function doPretty(statement: Statement | Block): string {\n            let o = '';\n            const indent = ' '.repeat(deep * 4);\n            if (isStatement(statement)) {\n                // statement\n                let args = '';\n\n                if (statement.args.length > 0) {\n                    args =\n                        ' ' +\n                        statement.args\n                            .map((arg) => {\n                                if (arg.type == 'block') {\n                                    return doPretty(arg.data).trim();\n                                } else if (arg.type == 'quote') {\n                                    return stringArgToString(arg.data);\n                                } else if (arg.type == 'text') {\n                                    return arg.data;\n                                } else if (arg.type == 'bracket') {\n                                    return '[' + arg.data + ']';\n                                }\n                            })\n                            .join(' ');\n                }\n\n                if (statement.statement == 'comment') {\n                    o += indent + '//' + (statement.comment as string) + '\\n';\n                } else if (statement.statement == 'multicomment') {\n                    o +=\n                        indent +\n                        '/*\\n' +\n                        (statement.comment as string)\n                            .trimStart()\n                            .replace(/^/, '\\n' + indent)\n                            .replace('\\n', indent) +\n                        '*/\\n';\n                } else {\n                    o += indent + statement.statement + args;\n                    let endNewLine = '\\n';\n                    if (o.endsWith('}')) {\n                        o += ';';\n                        endNewLine = '\\n\\n';\n                    } else {\n                        o += ';';\n                        endNewLine = '\\n';\n                    }\n\n                    if (statement.comment) {\n                        o +=\n                            ' //' +\n                            (\n                                statement.comment as {\n                                    statement: string;\n                                    args: Arg[];\n                                    comment: string;\n                                }\n                            ).comment;\n                    }\n\n                    o += endNewLine;\n                }\n            } else {\n                // block\n                o += indent + '{\\n';\n                deep++;\n                for (const statemen of statement) {\n                    o += doPretty(statemen);\n                }\n                deep--;\n                o += indent + '}\\n';\n            }\n            return o;\n        }\n        for (const statement of this.parsed) {\n            let newLine = '\\n';\n            if ((statement as Statement).statement !== undefined) {\n                if (\n                    (statement as Statement).statement === 'comment' ||\n                    (statement as Statement).statement === 'multicomment'\n                ) {\n                    newLine = '';\n                }\n            }\n            out += newLine + doPretty(statement);\n        }\n\n        out = out.trimStart();\n\n        // figure out how to just not make the extra new lines lol\n        const extraNewlines = out.match(/\\n{3}/gm);\n        if (extraNewlines) {\n            for (const newline of extraNewlines) {\n                // get position of newlines\n                const pos = out.indexOf(newline);\n                // replace the newlines with one newline\n                out =\n                    out.slice(0, pos) +\n                    '\\n\\n' +\n                    out.slice(pos + newline.length);\n            }\n        }\n\n        return out;\n    }\n    exec(initalContext?: Context): Context {\n        const ret = executeBlock(\n            this.parsed,\n            initalContext || {},\n            this.resolver\n        );\n        // transform the context into the right data format here\n        // fuck you\n        const newret: any = {};\n        for (const key in ret) {\n            if (key.startsWith('func_')) {\n                continue;\n            }\n            newret[key] = ret[key];\n        }\n        return newret;\n    }\n    bundle(): string {\n        const e = produce(this.parsed, (p: any) => {\n            const dofunny = (b: Block | Statement, parent?: Statement) => {\n                if (Array.isArray(b)) {\n                    b.forEach((e, i) => {\n                        if ((e as Statement).statement == 'import') {\n                            const impst = e as Statement;\n                            const toimp = impst.args[0].data as string;\n                            const imp = this.resolver(toimp);\n                            const parsed = new SCS(imp, this.resolver);\n                            const bundledDep = parsed.bundle();\n                            const newBlock = pe(bundledDep) as Block;\n                            newBlock.unshift({\n                                statement: 'comment',\n                                args: [],\n                                comment: ' *' + toimp + '*',\n                                location: {\n                                    start: { offset: 0, line: 0, column: 0 },\n                                    end: { offset: 0, line: 0, column: 0 },\n                                },\n                            } as Statement);\n                            b[i] = newBlock;\n                            return;\n                        }\n                        dofunny(e, parent);\n                    });\n                } else {\n                    b.args.forEach((c) => {\n                        if (c.type == 'block') {\n                            dofunny(c.data, b);\n                        }\n                    });\n                }\n            };\n            dofunny(p);\n        });\n        const n = new SCS('e;');\n        n.parsed = e;\n        return n.pretty();\n    }\n}\n\nexport { SCSFS } from './scsfs';\n","import type { Block } from './types';\nimport { find, isStatement } from './lib';\nimport produce from 'immer';\nimport { StatementMap } from './statements';\nimport clone from '@ungap/structured-clone';\nimport { SCS } from './scs';\nexport type Context = {\n    parent?: Context;\n    stop?: boolean;\n    statement?: string;\n    [key: string]: any;\n};\n\nexport type PArgs = (string | Context)[];\n\nexport function executeBlock(\n    data: Block,\n    initcontext: Context,\n    resolver: (filename: string) => string\n): Context {\n    let context = clone(initcontext);\n    for (const item of data) {\n        if (isStatement(item)) {\n            if (item.statement == 'function') {\n                context = produce(context, (c) => {\n                    let args: string[] = [];\n                    if (item.args.length == 3) {\n                        args = (item.args.splice(1, 1)[0].data as string).split(\n                            ' '\n                        );\n                    }\n                    const name = item.args[0].data as string;\n                    const body = item.args[1].data as Block;\n                    c['func_' + name] = { args, body };\n                });\n                continue;\n            } else if (item.statement == 'import') {\n                const name = item.args[0].data as string;\n                const data = resolver(name);\n                const parsed = new SCS(data, resolver);\n                context = executeBlock(parsed.parsed, context, resolver);\n                continue;\n            }\n            const parsedArgs: PArgs = [];\n            item.args.forEach((element) => {\n                if (element.type == 'block') {\n                    const blk = produce(\n                        executeBlock(\n                            element.data,\n                            { parent: context, statement: item.statement },\n                            resolver\n                        ),\n                        (r) => {\n                            delete r.parent;\n                            delete r.statement;\n                            delete r.stop;\n                        }\n                    );\n                    parsedArgs.push(blk);\n                } else {\n                    if (element.data.startsWith('$')) {\n                        const name = element.data.substring(1);\n                        const val = find(context, name);\n                        if (val == undefined) {\n                            throw new Error(`Variable ${name} not found`);\n                        }\n                        parsedArgs.push(val);\n                        return;\n                    }\n                    parsedArgs.push(element.data);\n                }\n            });\n            if (item.statement == 'call') {\n                const tocall = parsedArgs.shift() as string;\n                const args = parsedArgs;\n                const func = find(context, 'func_' + tocall);\n                if (!func) {\n                    throw new Error(`Function ${tocall} not found`);\n                }\n                const argMapping: { [key: string]: any } = {};\n                args.forEach((arg, i) => {\n                    argMapping[func.args[i]] = arg;\n                });\n                //console.log(\"calling function \"+tocall+\" with args \"+JSON.stringify(argMapping))\n                context = executeBlock(\n                    func.body,\n                    { ...context, ...argMapping },\n                    resolver\n                );\n                continue;\n            }\n            //console.log(\"executing\",item.statement,\"with\", parsedArgs)\n            context = executeStatement(item.statement, parsedArgs, context);\n            if (context.stop) {\n                return initcontext;\n            }\n        } else {\n            context = executeBlock(item, context, resolver);\n        }\n    }\n    return context;\n}\n\nfunction executeStatement(\n    statement: string,\n    args: PArgs,\n    icontext: Context\n): Context {\n    const def = (_: PArgs, c: Context) => {\n        c.unknownCommands = c.unknownCommands || [];\n        c.unknownCommands.push(statement);\n    };\n    return produce(icontext, (c) => {\n        const exec = StatementMap.get(statement) || def;\n        exec(args, c);\n    });\n}\n","import { getHours, getMinutes, getSeconds, parse } from 'date-fns';\nimport { Context } from './execute';\nimport { Statement, Block, TimeRange, Time } from './types';\n\nexport function isStatement(s: Statement | Block): s is Statement {\n    return (s as Statement).statement !== undefined;\n}\n\nexport function find(context: Context, item: string): any {\n    const dt = context[item];\n    if (dt != undefined) {\n        return dt;\n    } else {\n        if (context.parent) {\n            return find(context.parent, item);\n        } else {\n            //throw new Error(\"Unable to find item \"+item+\" in context.\")\n            return undefined;\n        }\n    }\n}\n\nexport function copyInto(src: any, dest: any) {\n    Object.keys(src).forEach((element) => {\n        dest[element] = src[element];\n    });\n}\n\n// range: 10:45 to 11:25\nexport function parseTimeRange(range: string): TimeRange {\n    //console.log(based)\n    //console.log(based)\n    const [start, end] = range.split(' to '); // ok\n    //console.log(start,end)\n    const startp = parse(start, 'H:mm', new Date());\n    const endp = parse(end, 'H:mm', new Date());\n    //console.log(startp, endp)\n    return {\n        start: dateToTime(startp),\n        end: dateToTime(endp),\n    };\n}\n\nexport function dateToTime(time: Date): Time {\n    return {\n        h: getHours(time),\n        m: getMinutes(time),\n        s: getSeconds(time),\n    };\n}\n// https://stackoverflow.com/a/50398144\nexport function getDaysArray(start: Date, end: Date) {\n    const arr = [];\n    for (\n        let dt = new Date(start);\n        dt <= new Date(end);\n        dt.setDate(dt.getDate() + 1)\n    ) {\n        arr.push(new Date(dt));\n    }\n    return arr;\n}\n\nexport function recurseInto(\n    b: Block | Statement,\n    cb: (s: Statement, parent?: Statement) => void,\n    parent?: Statement\n) {\n    if (Array.isArray(b)) {\n        b.forEach((e) => recurseInto(e, cb, parent));\n    } else {\n        cb(b, parent);\n        b.args.forEach((c) => {\n            if (c.type == 'block') {\n                recurseInto(c.data, cb, b);\n            }\n        });\n    }\n}\n\nexport function generateMatch(m: string): { type: string; num: number | null } {\n    const ptyper = m.split(' ');\n    let num: number | null = null;\n    let type = 'period';\n    if (ptyper.length == 1) {\n        const isNum = /^\\d+$/.test(ptyper[0]);\n        if (isNum) {\n            num = parseInt(ptyper[0]);\n        } else {\n            type = ptyper[0];\n        }\n    } else {\n        const [rtype, rnum] = ptyper;\n        num = parseInt(rnum);\n        type = rtype;\n    }\n    return { num, type };\n}\n","import type { Context, PArgs } from './execute';\r\nimport {\r\n    find,\r\n    copyInto,\r\n    parseTimeRange,\r\n    getDaysArray,\r\n    generateMatch,\r\n} from './lib';\r\nimport { isAfter, isBefore, isSameDay } from 'date-fns';\r\ntype StatementFunc = (args: PArgs, context: Context) => void;\r\n\r\nexport const StatementMap = new Map<string, StatementFunc>()\r\n    .set('schedule', (args, c) => {\r\n        if (c.statement) {\r\n            //console.log(c.statement)\r\n            if (c.statement == 'event') {\r\n                const schedules = find(c, 'schedules');\r\n                if (!schedules) {\r\n                    throw new Error('unable to find schedules');\r\n                }\r\n                const sch = schedules[args[0] as string];\r\n                if (!sch) {\r\n                    throw new Error(\r\n                        ('Cannot find schedule ' + args[0]) as string\r\n                    );\r\n                }\r\n                c.schedule = args[0] as string;\r\n            } else {\r\n                c.schedule = args;\r\n                return;\r\n            }\r\n        } else {\r\n            // define top level schedule\r\n            c.schedules = c.schedules || {};\r\n            const name = args.shift() as string;\r\n            const data = args.pop() as Context;\r\n            c.schedules[name] = data;\r\n        }\r\n    })\r\n    .set('class', (args, c) => {\r\n        c.classes = c.classes || [];\r\n        let outc: any = {};\r\n        const typeM = args[0] as string;\r\n        const timeRange = args[1] as string;\r\n        const ptimerange = parseTimeRange(timeRange);\r\n        outc = { ...ptimerange };\r\n        const { type, num } = generateMatch(typeM);\r\n        outc = { ...outc, type, num };\r\n        c.classes.push(outc);\r\n    })\r\n    .set('event', (args, c) => {\r\n        c.events = c.events || [];\r\n        c.events.push(args[0]);\r\n    })\r\n    .set('terms', (args, c) => {\r\n        let t: { termIndex: number; start: Date; end: Date }[] = (\r\n            args[0] as Context\r\n        ).terms;\r\n        if (t == undefined) {\r\n            t = [];\r\n        }\r\n        c.terms = t;\r\n        const displayDate = find(c, 'displayDate') || new Date();\r\n        const newTerm = t.filter((term) => {\r\n            return (\r\n                (isAfter(displayDate, term.start) ||\r\n                    isSameDay(displayDate, term.start)) &&\r\n                (isBefore(displayDate, term.end) ||\r\n                    isSameDay(displayDate, term.end))\r\n            );\r\n        });\r\n        if (newTerm.length == 0) {\r\n            c.term = 0;\r\n        } else {\r\n            c.term = newTerm[0].termIndex + 1;\r\n        }\r\n    })\r\n    .set('term', (args, c) => {\r\n        const termIndex = parseInt(args[0] as string) - 1;\r\n        const start = new Date(args[1] as string);\r\n        const end = new Date(args[2] as string);\r\n        c.terms = c.terms || [];\r\n        c.terms.push({ termIndex, start, end });\r\n    })\r\n    .set('only', (args, c) => {\r\n        // only <item> <compare> searches the context for the item \"item\" and compares it,\r\n        // @TODO allow many types of comparisons\r\n        const [item, compare] = args as string[];\r\n        const toc = find(c, item);\r\n        if (toc == undefined) {\r\n            console.warn(\r\n                'Unable to find item',\r\n                item,\r\n                'in context, this is probably an issue'\r\n            );\r\n        }\r\n        c.stop = toc?.toString() != compare;\r\n    })\r\n    .set('lunches', (args, c) => {\r\n        const tech = args[0] as Context;\r\n        c.lunches = {};\r\n        tech.teachers.forEach((element: any) => {\r\n            c.lunches[element.id] = element.lunch;\r\n        });\r\n        c.teachers = tech.teachers;\r\n    })\r\n    .set('teacher', (args, c) => {\r\n        const [name, id, _lunch] = args as string[];\r\n        const lunch = parseInt(_lunch);\r\n        c.teachers = c.teachers || [];\r\n        c.teachers.push({ name, id, lunch });\r\n    })\r\n    .set('inherit', (args, c) => {\r\n        const toHer = args[0] as string;\r\n        const schs = find(c, 'schedules');\r\n        if (!schs) {\r\n            throw new Error('No schedules in file!');\r\n        }\r\n        const t = schs[toHer];\r\n        if (!t) {\r\n            throw new Error('Schedule ' + toHer + ' doesnt exist!');\r\n        }\r\n        copyInto(t, c);\r\n    })\r\n    .set('description', setSimple('description'))\r\n    .set('info', setSimple('info'))\r\n    .set('message', setSimple('message'))\r\n    .set('date', (args, c) => {\r\n        c.dates = c.dates || [];\r\n        c.dates.push(new Date(args[0] as string));\r\n    })\r\n    .set('from', (args, c) => {\r\n        if (c.statement == 'event') {\r\n            const from = args[0] as string;\r\n            const tost = args[1] as string;\r\n            if (tost != 'to') {\r\n                console.warn(\"(from) Expected 'to' but got\", tost);\r\n            }\r\n            const to = args[2] as string;\r\n            c.dates = c.dates || [];\r\n            c.dates.push(...getDaysArray(new Date(from), new Date(to)));\r\n        } else if (c.statement == 'lunchConfig') {\r\n            c.studentLunches = c.studentLunches || {};\r\n            c.studentLunches.basedOn = args[0] as string;\r\n        } else {\r\n            c.from = args;\r\n        }\r\n    })\r\n    .set('set', (args, c) => {\r\n        const key = args.shift() as string;\r\n        const value = args.shift();\r\n        c[key] = value;\r\n    })\r\n    .set('config', (args, c) => {\r\n        c.config = c.config || {};\r\n        const key = args.shift() as string;\r\n        const value = args.shift();\r\n        c.config[key] = value;\r\n    })\r\n    .set('comment', empty)\r\n    .set('multicomment', empty)\r\n    .set('import', empty)\r\n    .set('function', empty)\r\n    .set('call', empty)\r\n    .set('lunchConfig', (args, c) => {\r\n        copyInto(args[0] as Context, c);\r\n    })\r\n    .set('passing', (args, c) => {\r\n        c.studentLunches = c.studentLunches || {};\r\n        c.studentLunches.passing = args[0] as string;\r\n    })\r\n    .set('lunch', (args, c) => {\r\n        const [lunchid, durataion] = args as string[];\r\n        c.studentLunches = c.studentLunches || {};\r\n        c.studentLunches.lunches = c.studentLunches.lunches || {};\r\n        c.studentLunches.lunches[lunchid] = parseTimeRange(durataion);\r\n    })\r\n    .set('user', (args, c) => {\r\n        // currently only uses `user classes contains` so thats all im going to support\r\n        const classes = args.shift();\r\n        const contains = args.shift();\r\n        if (classes != 'classes' || contains != 'contains') {\r\n            throw new Error('Invalid user statement (lmao)');\r\n        }\r\n        const checks: { type: string; num: number | null }[] = [];\r\n        for (const what of args) {\r\n            checks.push(generateMatch(what as string));\r\n        }\r\n        // format\r\n        // {\r\n        // \"user\": {classes: [{type: \"period\", num: 1}, {type: \"period\", num: 2}]}\r\n        // }\r\n        // gl hf\r\n        const userinfo = find(c, 'user') as\r\n            | { classes?: { type: string; num: number | null }[] }\r\n            | undefined;\r\n        if (!userinfo) {\r\n            c.stop = true;\r\n            return;\r\n        }\r\n        userinfo.classes = userinfo.classes || [];\r\n        for (const check of checks) {\r\n            const found = userinfo.classes.find(\r\n                (e) => e.type == check.type && e.num == check.num\r\n            );\r\n            if (found) {\r\n                c.stop = false;\r\n                return;\r\n            }\r\n        }\r\n        c.stop = true;\r\n    })\r\n    .set('self', (args, c) => {\r\n        // currently only uses `self classes contains` so thats all im going to support\r\n        const classes = args.shift();\r\n        const contains = args.shift();\r\n        if (classes != 'classes' || contains != 'contains') {\r\n            throw new Error('Invalid self statement (lmao)');\r\n        }\r\n        const checks: { type: string; num: number | null }[] = [];\r\n        for (const what of args) {\r\n            checks.push(generateMatch(what as string));\r\n        }\r\n        // format\r\n        // {\r\n        // \"user\": {classes: [{type: \"period\", num: 1}, {type: \"period\", num: 2}]}\r\n        // }\r\n        // gl hf\r\n        const cls = c.classes as\r\n            | { type: string; num: number | null }[]\r\n            | undefined;\r\n        if (!cls) {\r\n            c.stop = true;\r\n            return;\r\n        }\r\n        for (const check of checks) {\r\n            const found = cls.find(\r\n                (e) => e.type == check.type && e.num == check.num\r\n            );\r\n            if (found) {\r\n                c.stop = false;\r\n                return;\r\n            }\r\n        }\r\n        c.stop = true;\r\n    })\r\n    .set('day', (args, c) => {\r\n        const _start = args.shift() as string;\r\n        let data: Context;\r\n        let _end: string;\r\n        if (typeof args[0] == 'string') {\r\n            const to = args.shift();\r\n            if (to != 'to') {\r\n                throw new Error('expected to, got ' + to);\r\n            }\r\n            _end = args.shift() as string;\r\n            data = args.shift() as Context;\r\n        } else {\r\n            _end = _start;\r\n            data = args.shift() as Context;\r\n        }\r\n        const end = parseInt(_end) + 1;\r\n        const start = parseInt(_start);\r\n        const values = Array.from({ length: end - start }, (v, k) => k + start);\r\n        c.days = c.days || {};\r\n        values.forEach((m) => {\r\n            c.days[m.toString()] = data;\r\n        });\r\n    })\r\n    .set('events', (args, c) => {\r\n        const days = (args[0] as Context).days;\r\n        c.eventOverrides = days;\r\n    })\r\n    .set('remove', (args, c) => {\r\n        const classes = c.classes as\r\n            | { type: string; num: number | null }[]\r\n            | undefined;\r\n        if (!classes) {\r\n            return;\r\n        }\r\n        const toRemove = args.map((e) => generateMatch(e as string));\r\n        let lastRemovedIndex = -1;\r\n        c.classes = classes.filter((e, i) => {\r\n            const found = toRemove.find(\r\n                (f) => f.type == e.type && f.num == e.num\r\n            );\r\n            if (found) {\r\n                lastRemovedIndex = i;\r\n            }\r\n            return !found;\r\n        });\r\n        c.lastOP = lastRemovedIndex;\r\n    })\r\n    .set('force', (args, c) => {\r\n        c.forced = c.forced || {};\r\n        const key = args.shift() as string;\r\n        const value = args.shift();\r\n        c.forced[key] = value;\r\n    })\r\n    .set('replace', (args, c) => {\r\n        /*replace class [arrival] with {\r\n            class [period 0] [6:30 to 7:30];\r\n        };*/\r\n        args.shift(); // class\r\n        const matcher = args.shift() as string;\r\n        args.shift(); // with\r\n        const data = args.shift() as Context;\r\n        if (!data.classes) {\r\n            return;\r\n        }\r\n        const classes = c.classes as\r\n            | { type: string; num: number | null }[]\r\n            | undefined;\r\n        if (!classes) {\r\n            return;\r\n        }\r\n        const toRemove = generateMatch(matcher);\r\n        const indexOfToReplace = classes.findIndex((e) => {\r\n            return toRemove.type == e.type && toRemove.num == e.num;\r\n        });\r\n        if (indexOfToReplace == -1) {\r\n            return;\r\n        }\r\n        (c.classes as any[]).splice(indexOfToReplace, 1, ...data.classes);\r\n        c.lastOP = indexOfToReplace;\r\n    })\r\n    .set('insert', (args, c) => {\r\n        /*\r\n        insert {\r\n            class [period 11] [$eleven];\r\n            class [period 12] [$twelve];\r\n            class [period 13] [$thirteen];\r\n        } last operation;\r\n        */\r\n        const toInsert = args.shift() as Context;\r\n        if (!toInsert.classes) {\r\n            return;\r\n        }\r\n        let index = -1;\r\n        //console.log(args)\r\n        if (args.join(' ') == 'last operation') {\r\n            index = c.lastOP;\r\n        } else {\r\n            args.shift(); // at\r\n            //console.log(args)\r\n            index = parseInt(args[0] as string);\r\n        }\r\n        const classes = c.classes as\r\n            | { type: string; num: number | null }[]\r\n            | undefined;\r\n        if (!classes) {\r\n            return;\r\n        }\r\n        if (index == -1) {\r\n            return;\r\n        }\r\n        //console.log(index);\r\n        (c.classes as any[]).splice(index, 0, ...toInsert.classes);\r\n    });\r\n\r\nfunction empty(args: PArgs, c: Context) {\r\n    c;\r\n}\r\n\r\nfunction setSimple(name: string) {\r\n    return (args: PArgs, c: Context) => {\r\n        c[name] = args.join(' ');\r\n    };\r\n}\r\n// you could import statements from other files and add them to the map.\r\n\r\nexport const _statements = Array.from(StatementMap.keys());\r\n","import { readFileSync } from 'fs';\r\nimport * as peggy from 'peggy';\r\n\r\n//const start = performance.now()\r\nconst gened = peggy.generate(\r\n    readFileSync(__dirname + '/grammer.pegjs', 'utf-8'),\r\n    {\r\n        output: 'parser',\r\n        cache: true,\r\n    }\r\n);\r\n//const end = performance.now()\r\nexport const parse = gened.parse;\r\n//export const parseTime = end - start;\r\n","// add types here\nexport type Block = (Statement | Block)[];\nexport type Statement = {\n    statement: string;\n    args: Arg[];\n    comment?: { statement: string; args: Arg[]; comment: string } | string;\n    location: {\n        start: {\n            offset: number;\n            line: number;\n            column: number;\n        };\n        end: {\n            offset: number;\n            line: number;\n            column: number;\n        };\n    };\n};\n\nexport type MinifyOptions = {\n    keepMultiLineComments?: boolean;\n    uncompressTopLevelMultiLineComments?: boolean;\n    keepSingleLineComments?: boolean;\n};\n\nexport type Arg = BlockArg | QuoteArg | TextArg | BracketArg;\n\nexport type BlockArg = {\n    type: 'block';\n    data: Block;\n};\nexport type QuoteArg = {\n    type: 'quote';\n    data: string;\n};\nexport type TextArg = {\n    type: 'text';\n    data: string;\n};\nexport type BracketArg = {\n    type: 'bracket';\n    data: string;\n};\n\nexport type Time = {\n    h: number;\n    m: number;\n    s: number;\n};\n\nexport type TimeRange = {\n    start: Time;\n    end: Time;\n};\n\nexport type Output = {\n    // piss\n};\n\nexport enum LintLevel {\n    info,\n    warn,\n    error,\n}\n\nexport type LintObject = {\n    location: {\n        start: {\n            offset: number;\n            line: number;\n            column: number;\n        };\n        end: {\n            offset: number;\n            line: number;\n            column: number;\n        };\n    };\n    level: LintLevel;\n    message: string;\n};\n","import { LintLevel, Statement } from './types';\r\n\r\nexport type Checker = (\r\n    statement: Statement,\r\n    parent?: Statement\r\n) => { message: string; level: LintLevel } | void;\r\n\r\nfunction combine(checks: Checker[]): Checker {\r\n    return (statement: Statement, parent?: Statement) => {\r\n        for (const check of checks) {\r\n            const err = check(statement, parent);\r\n            if (err) {\r\n                return err;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nfunction anyof(t: any[]) {\r\n    for (const item of t) {\r\n        if (!item) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction varArgsofType(type: args, start: number) {\r\n    return (statement: Statement, parent?: Statement) => {\r\n        const argstocheck = statement.args.slice(start);\r\n        for (const item of argstocheck) {\r\n            if (item.type != type) {\r\n                return {\r\n                    message:\r\n                        'All varargs of statement ' +\r\n                        statement.statement +\r\n                        ' must be of type ' +\r\n                        formatType(type) +\r\n                        ' not ' +\r\n                        formatType(item.type),\r\n                    level: LintLevel.error,\r\n                };\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nfunction mustEqual(index: number, arg: args, value: string): Checker {\r\n    return (statement: Statement, parent?: Statement) => {\r\n        if (\r\n            statement.args[index].type == arg &&\r\n            statement.args[index].data != value\r\n        ) {\r\n            return {\r\n                message: `Argument ${index} of ${statement.statement} must be ${value}, not ${statement.args[index].data}`,\r\n                level: LintLevel.error,\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\nfunction parenting(parents: { [key: string]: Checker }): Checker {\r\n    return (statement: Statement, parent?: Statement) => {\r\n        let parentStatement: string;\r\n        if (!parent) {\r\n            parentStatement = 'root';\r\n        } else {\r\n            parentStatement = parent.statement;\r\n        }\r\n        if (!Object.keys(parents).includes(parentStatement)) {\r\n            return {\r\n                message: `Statement ${\r\n                    statement.statement\r\n                } must be inside ${Object.keys(parents).join(\r\n                    ', '\r\n                )}, not ${parentStatement}`,\r\n                level: LintLevel.error,\r\n            };\r\n        } else {\r\n            return parents[parentStatement](statement, parent);\r\n        }\r\n    };\r\n}\r\n\r\nfunction simple(args: args[]) {\r\n    return combine([\r\n        hasAmtOfArgs(args.length),\r\n        ...args.map((n, i) => argumentOfType(i, n)),\r\n    ]);\r\n}\r\n\r\nfunction formatType(t: string): string {\r\n    return (\r\n        {\r\n            text: 'text',\r\n            block: 'block',\r\n            quote: 'quoted string',\r\n            bracket: 'bracketed string',\r\n        }[t] || t\r\n    );\r\n}\r\n\r\ntype args = 'quote' | 'text' | 'block' | 'bracket';\r\n\r\nfunction argumentOfType(argumentIndex: number, type: args | args[]): Checker {\r\n    const ot = typeof type == 'string' ? [type] : type;\r\n    return (statement: Statement, parent?: Statement) => {\r\n        if (!ot.includes(statement.args[argumentIndex].type)) {\r\n            return {\r\n                level: LintLevel.error,\r\n                message: `Argument ${argumentIndex} of ${\r\n                    statement.statement\r\n                } must be any of (${ot\r\n                    .map((t) => formatType(t))\r\n                    .join(', ')}), not a ${formatType(\r\n                    statement.args[argumentIndex].type\r\n                )}`,\r\n            };\r\n        }\r\n    };\r\n}\r\nfunction hasAmtOfArgs(amt: number) {\r\n    return (statement: Statement, parent?: Statement) => {\r\n        if (statement.args.length != amt) {\r\n            return {\r\n                message: `Statement ${statement.statement} must have ${amt} arguments, not ${statement.args.length}`,\r\n                level: LintLevel.error,\r\n            };\r\n        }\r\n    };\r\n}\r\n\r\nexport const checkers = new Map<string, Checker>()\r\n    .set(\r\n        'schedule',\r\n        parenting({\r\n            root: simple(['text', 'block']),\r\n            event: simple(['text']),\r\n        })\r\n    )\r\n    .set(\r\n        'term',\r\n        parenting({\r\n            terms: simple(['text', 'bracket', 'bracket']),\r\n        })\r\n    )\r\n    .set(\r\n        'info',\r\n        parenting({\r\n            event: simple(['quote']),\r\n        })\r\n    )\r\n    .set(\r\n        'description',\r\n        parenting({\r\n            schedule: simple(['quote']),\r\n        })\r\n    )\r\n    .set('root', () => {\r\n        return { message: 'reserved statement: root', level: LintLevel.error };\r\n    })\r\n    .set('call', (s, p) => {\r\n        if (s.args.length == 0) {\r\n            return {\r\n                message: 'Statement call requires 1+ arguments',\r\n                level: LintLevel.error,\r\n            };\r\n        }\r\n    })\r\n    .set('comment', simple([]))\r\n    .set('multicomment', simple([]))\r\n    .set('function', (s, p) => {\r\n        if (s.args.length < 2 || s.args.length > 3) {\r\n            return {\r\n                message: 'Statement call requires 2-3 arguments',\r\n                level: LintLevel.error,\r\n            };\r\n        }\r\n        if (s.args.length == 2) {\r\n            return simple(['text', 'block'])(s, p);\r\n        } else {\r\n            return simple(['text', 'bracket', 'block'])(s, p);\r\n        }\r\n    })\r\n    .set('class', simple(['bracket', 'bracket']))\r\n    .set('terms', simple(['block']))\r\n    .set('lunches', simple(['block']))\r\n    .set('only', simple(['text', 'text']))\r\n    .set('teacher', simple(['bracket', 'text', 'text']))\r\n    .set('set', simple(['text', 'text']))\r\n    .set('config', simple(['text', 'text']))\r\n    .set('message', simple(['quote']))\r\n    .set(\r\n        'user',\r\n        combine([\r\n            mustEqual(0, 'text', 'classes'),\r\n            mustEqual(1, 'text', 'contains'),\r\n            varArgsofType('bracket', 2),\r\n        ])\r\n    )\r\n    .set(\r\n        'self',\r\n        combine([\r\n            mustEqual(0, 'text', 'classes'),\r\n            mustEqual(1, 'text', 'contains'),\r\n            varArgsofType('bracket', 2),\r\n        ])\r\n    )\r\n    .set('event', simple(['block']))\r\n    .set('inherit', simple(['text']))\r\n    .set('date', simple(['bracket']))\r\n    .set('lunchConfig', simple(['block']))\r\n    .set('passing', simple(['bracket']))\r\n    .set('lunch', simple(['bracket', 'bracket']))\r\n    .set(\r\n        'from',\r\n        parenting({\r\n            lunchConfig: simple(['bracket']),\r\n            event: simple(['bracket', 'text', 'bracket']),\r\n        })\r\n    )\r\n    .set('import', simple(['quote']))\r\n    .set('events', simple(['block']))\r\n    .set('day', (s, p) => {\r\n        switch (s.args.length) {\r\n            case 2:\r\n                return combine([\r\n                    argumentOfType(0, 'bracket'),\r\n                    argumentOfType(1, 'block'),\r\n                ])(s, p);\r\n            case 4:\r\n                return combine([\r\n                    argumentOfType(0, 'bracket'),\r\n                    mustEqual(1, 'text', 'to'),\r\n                    argumentOfType(2, 'bracket'),\r\n                    argumentOfType(3, 'block'),\r\n                ])(s, p);\r\n            default:\r\n                return {\r\n                    message: 'Statement day requires 2 or 4 arguments',\r\n                    level: LintLevel.error,\r\n                };\r\n        }\r\n    })\r\n    .set('remove', varArgsofType('bracket', 0))\r\n    .set('force', simple(['text', 'text']))\r\n    .set(\r\n        'replace',\r\n        combine([\r\n            mustEqual(0, 'text', 'class'),\r\n            argumentOfType(1, 'bracket'),\r\n            mustEqual(2, 'text', 'with'),\r\n            argumentOfType(3, 'block'),\r\n        ])\r\n    )\r\n    .set('insert', simple(['block', 'text', 'text']));\r\n","import { isSameDay } from 'date-fns';\nimport { Context } from './execute';\nimport { SCS } from './scs';\n\nexport class SCSFS {\n    files: { [key: string]: string } = {};\n    add(name: string, data: string) {\n        this.files[name] = data;\n    }\n    addAsync(\n        files: { [key: string]: string },\n        fetcher: (name: string) => Promise<string>\n    ) {\n        return Promise.all(\n            Object.keys(files).map(async (f) => {\n                this.add(f, await fetcher(files[f]));\n            })\n        );\n    }\n    scheduleFor(\n        filename: string,\n        date: Date,\n        context?: Context\n    ): { schedule: unknown; event: unknown } | undefined {\n        // @todo pls add type\n        // this function should do way more processing, ie including lunch info\n        const file = this.files[filename];\n        if (!file) {\n            throw new Error(`File ${filename} not found`);\n        }\n        const parsed = new SCS(file, this.resolve.bind(this));\n        return parsed.scheduleFor(date, context);\n    }\n    exec(filename: string, context?: Context) {\n        const file = this.files[filename];\n        if (!file) {\n            throw new Error(`File ${filename} not found`);\n        }\n        const parsed = new SCS(file, this.resolve.bind(this));\n        return parsed.exec(context);\n    }\n    resolve(filename: string): string {\n        const data = this.files[filename];\n        if (!data) {\n            throw new Error(`File ${filename} not found`);\n        }\n        return data;\n    }\n    bundle(filename: string) {\n        const file = this.files[filename];\n        if (!file) {\n            throw new Error(`File ${filename} not found`);\n        }\n        const parsed = new SCS(file, this.resolve.bind(this));\n        return parsed.bundle();\n    }\n}\n"],"names":[],"version":3,"file":"scs.mjs.map"}